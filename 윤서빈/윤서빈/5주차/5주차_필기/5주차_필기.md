# 5주차

## 1. HTTP서버 만들기

노드는 자바스크립트 실행기 서버가 아님

![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/Untitled.png)

- 서버와 클라이언트의 관계
    - 클라이언트가 서버로 요청을 보냄
    - 서버는 요청을 처리
    - 처리 후 클라이언트로 응답을 보냄
- 예 : 웹브라우저(클라이언트)가 [네이버.com](http://네이버.com) (네이버 서버 : 컴퓨터)을 검색
    
           웹브라우저에서 네이버 서버에 가서 네이버 사이트를 받아와야 함
    
           네이버 서버는 다시 클라이언트로 응답을 보내주는 것
    
- 공통된 요청 언어가 HTTP라고 생각하면 된다.
- 노드로 HTTP 서버 만들기
    - http 요청에 응답하는 노드 서버
        - createServer 로 요청 이벤트에 대기
        - http 모듈을 제공해줌
        - req 객체는 요청에 관한 정보, res 객체는 응답에 관한 정보가 담겨 있음
        - 노드가 실행하는 순간 서버도 프로그램이기 때문에 프로세스로 올려야함
            - 프로세스로 올릴 때 포트를 하나 잡아먹음
        - 서버를 실행하는 경우에는 다음 명령어를 받는것이 아니라 거기서 멈춰있음
        
        → listen 을 하는 경우 터미널 하나를 잡아먹음 8080포트와 연결이 되어 다른 동작을 할 수 없게 됨
        
        ![스크린샷 2024-05-13 오후 7.56.13.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.56.13.png)
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/Untitled%201.png)
        
        - [naver.com](http://naver.com) 와 같은 도메인을 구입하지 않았음 but 주소가 필요
        - [localhost](http://localhost)  : 컴퓨터 내부 주소 / 도메인을 지원함
            - 외부에서는 접근 불가능 (다른 컴퓨터 안됨, 내 컴퓨터에서만 가능 - 개발자용 서버라고 봐야함 )
            - 외부로 공개를 하고 싶다면 공개를 하기위한 웹서버 설정을 해야함(배포 - 15장에서 함…)
        - 8080이라는 포트에 프로세스에 띄우고 클라이언트가 요청을 해서 응답을 받아봄
        - 대부분의 서버는 포트가 존재함 but 거의 생략을 하기 때문에 못 봤을 뿐 다 있음
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/Untitled%202.png)
        
        - 포트가 좋은 점 : 도메인(호스트) 하나에 443, 444, 445 등 포트만 다르게 해도 다른 프로그램들을 보여줄 수 있음
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/Untitled%203.png)
        
        - 서버를 수정시에는 껐다가 다시 켜주어야 반영이 됨
        - callback 을 이벤트로 밖으로 빼줄 수도 있음

## 2. fs로 HTML 읽어 제공하기

![스크린샷 2024-05-13 오후 8.16.44.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.16.44.png)

- 이렇게 html 로 보내주어도 문자열 / html 구분을 못하는 브라우저 존재함 ( 사파리…)
- 직접 html 이라는 것을 알려주어야 함
- res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'})
- 해당 코드를 통해 html이라는 것과 한글을 인식하도록 알려줌
    
    ![스크린샷 2024-05-13 오후 8.23.09.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.23.09.png)
    
    - server, server1 등 연속적으로 해당코드를 적어주면 여러개의 포트를 하나의 도메인에 띄워줄 수 있음
- html 부분의 경우 따로 html 파일을 만들어 실행을 해주는 것이 훨씬 효율적

![스크린샷 2024-05-13 오후 9.01.15.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.01.15.png)

## 3. Rest API 서버 만들기

- 서버에 요청을 보낼 때는 주소를 통해 요청의 내용을 표현
    - /index.html → 파일을 보내달라는 뜻
    - 파일이 아니라 추상적인 것을 보내달라고 요청해도 됨 (id가 zerocho인 사용자의 정보, 누구에게 돈을 보내달라 … 등)
        - 클라이언트는 서버에게 어떤 요구를 할 수 있다. 받아들일지 말지는 서버가 결정
        - 주로 서버가 주도를 잡음 - 어떤걸 나에게 요청할 수 있는지 미리 알려줌
        - 클라이언트는 주소 중 몇개를 골라 요청을 보냄
    - 주소 정할 때 규칙을 Rest API 를 주로 따름
        - /user : 사용자 정보에 관한 정보를 요청하는 것
        - /post : 게시글에 관련된 자원을 요청하는 것
        - 예측이 가능해 해킹의 위험이 높음 - 보안을 신경써야함
    - http 요청 메서드
        - GET : 서버 자원을 가져오라고 할 떄
        - POST : 서버에 자원을 새로 등록 ( 혹은 뭘 써야할 지 애매할 때 - 로그인을 해라 등)
        - PUT : 서버의 자원을 요청에 들어있는 자원으로 치환하고자 할 때 (전체 수정 - zerocho를 아예 다른 사람으로 바꿀 때)
        - PATCH : 서버 자원의 일부만 수정하고자 할 때 (부분 수정 - 자신의 나이만 수정)
        - DELETE : 서버의 자원을 삭제하고자 할 때
- http 프로토콜
    - req : 요청에 관한 것
    - res : 응답에 관한 것
    - 주소차에 [localhost:8082](http://localhost:8082) → get 요청을 보내는 것 (페이지를 요청하는 것)
        
        ![스크린샷 2024-05-14 오후 1.51.24.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.51.24.png)
        
        ![스크린샷 2024-05-14 오후 1.55.44.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.55.44.png)
        
        - get 요청을 보낸 것을 확인 할 수 있음
        - response Headers
            - content-Type 은 코드로 작성해준것이며
            - Date, Transfer-Encoding, X-DNS-Prefetch-Control - 알아서 넣어준것
        - request Headers
            - 요청을 보낼 때 들어가는 header - 브라우저가 알아서 넣어줌
        - header
            - 데이터들을 위한 데이터
            - html을 응답해주는데 날짜나 한글쓸수있고, 성공적이었다. get이었다. 등등
            - accept : 이런 형식이 아니면 브라우저는 안받겠다고 서버에게 알려줌

## 4. post, put, delete 요청 보내기

- a 태그도 get 요청
    
    ![스크린샷 2024-05-14 오후 2.15.23.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.15.23.png)
    
    - 못찾았을 경우에는 200이 아닌 404을 보내주어 못찾았다는 것을 알려줌
    - 사용자를 등록 - post user
    
    ```
    else if (req.method === "POST") {
            if (req.url === "/user") {
              let body = "";
              // 요청의 body를 stream 형식으로 받음
              req.on("data", (data) => {
                body += data;
              });
              // 요청의 body를 다 받은 후 실행됨
              return req.on("end", () => {
                console.log("POST 본문(Body):", body);
                const { name } = JSON.parse(body);
                const id = Date.now();
                users[id] = name;
                res.writeHead(201, { "Content-Type": "text/plain; charset=utf-8" });
                res.end("등록 성공");
              });
            }
    ```
    
    - 사용자 정보를 프론트에 보내주는 것
    
    ```jsx
    else if (req.url === "/users") {
              res.writeHead(200, {
                "Content-Type": "application/json; charset=utf-8",
              });
              return res.end(JSON.stringify(users));
            }
    ```
    
    ![스크린샷 2024-05-14 오후 2.23.31.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.23.31.png)
    
    ![스크린샷 2024-05-14 오후 2.24.20.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.24.20.png)
    
    ![스크린샷 2024-05-14 오후 2.26.39.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.26.39.png)
    
    ![스크린샷 2024-05-14 오후 2.27.45.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.27.45.png)
    
    ![스크린샷 2024-05-14 오후 2.28.29.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20cd23a808d4044058b75db4b544358137/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-05-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.28.29.png)
    
    - user 라는 post에 들어가면 요청 데이터는 payload 에 들어가면 확인이 되고 응답 데이터는 response에서 확인이 가능
    - 200은 단순 성공 , 201은 생성됨 이라는 의미를 가지고 있음
    - 수정을 하게 되면 put요청이 실행이 된다.