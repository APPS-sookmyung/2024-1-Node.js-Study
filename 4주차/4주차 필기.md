# 4주차

## 1. crypto(단방향 암호화) 와 util

### 단방향 암호화

암호화 가능 복호화 불가능

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled.png)

암호화한 것을 항상 해시화하면 무조건 암호화했던 문자열로 바뀜

암호화했던 문자열은 절대 서버에 없어서 해킹에 강함

해쉬화 하는 알고리즘은 많음 - pdkdf2, scrypt

### 양방향 암호화

암호화할 때, 복호화할 때 같은 key 사용 

해커들이 key를 훔치려고 함 - 관리 중요

프론트 - 서버 불가능 → 프론트는 코드가 다 공개되기 때문에 위험함

### util

deprecated - 경고창이 출력 → 이걸 보면 다른 함수를 쓰게 됨, 버전을 올리게 될 때 삭제

promisfy - 옛날 함수들이 callback 으로 되어 있음 → promise 지원을 아직 하지 않는 곳이 많음 그래서 이걸로 callback 함수를 감싸주면 promise 함수로 사용가능 (error, data) ⇒ {} 형식이어야함

## 2. worker_threads

노드에서 멀티 스레드 방식으로 작업 가능

처음에 메인스레드 실행 → 워커스레드 들을 생성 → 메인스레드가 일을 분배해줌 → 일이 끝나면 메인스레드로 보내줌 → 메인스레드가 합침 → 최종 결과

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%201.png)

- 하나의 워커 생성
- 부모에서 ping 워커는 pong 에서 부모에게

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%202.png)

- 두개의 워커스레드 생성
- size = 0 → 모두 끝난거

워커스레드를 늘린다고 해서 늘린만큼 줄어들지 않음 ← 데이터가 보내지는 시간 / 코어의 개수에 따라서 달라짐

다른 언어로 짜는게 좋음

## 3. child_process

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%203.png)

다른 언어로 쓰인 파일 실행이 가능함

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%204.png)

- 파이썬 실행이 가능해지는 것 → 파이썬에게 이거좀 실행해줘라고 요청만 할 수 있음

## 4. 파일 시스템 사용하기

### fs

- 브라우저는 파일 시스템 접근 안됨
- 노드 가능 - 보안 조심
    
    노드에서는 동기면 블로킹 비동기면 논블로킹이라고 보면 됨
    
- 비동기면 callback을 백그라운드로 보냄 - 누가 먼저 끝날지는 운영체제만 앎
    
    순서보장이 안됨
    

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%205.png)

- 비동기는 첫번째 수행 → 바로 다음으로 넘어감 → 바로바로 백그라운드로 보냄
    
    작업들을 순서대로 다 수행 → 완료되는 순서대로 taskque로 감
    
    순서를 어떻게 맞출건지 중요
    
    서버 시작 후에는 비동기를 주로 사용
    
- 동기는 처음 한번 실행 혹은 서버 시작 전 초기화할 때

## 5. 버퍼와 스트림

- 버퍼: 일정한 크기로 모아두는 데이터 → 모으다가 특정 크기가 되면 보내줌
    
    스트림: 버퍼들이 계속 전달 
    
- 100메가 파일
    
    버퍼를 100메가로 설정한다면 100메가가 될때까지 기다렸다가 보내줌
    
    스트림을 1메가로 설정한다면 1메가씩 받을 때마다 보내줌 - 100번 
    
- 버퍼 사용
    
    ![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%206.png)
    
- 스트림 방식
    
    서버 메모리가 작더라도 큰 파일을 전송할 수 있다. 
    
    메모리 관리에 용이함 
    

## 6. pipe와 스트림 메모리 효율 확인

스트림 방식은 몇 메가씩 일정하게 계속해서 전달하는 것 = 파이프가 연결된 것

→ 파이프로 연결이 가능 (파이핑)

버퍼들을 연결하는 것

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%207.png)

→ 파일 복사

- 파일 및 폴더 생성

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%208.png)

## 7. 스레드풀과 커스텀 이벤트

- 스레드풀
    
    fs, crypto, zlib 모듈의 메서드를 실행할 때는 백그라운드에서 동시에 생행됨
    
    노드는 기본 백그라운드에서 4개가 동시에 돌아가게 설정되어 있음
    
    스레드풀 사이즈는 바꿔줄 수 있음 - 코어갯수에 맞게 조절해주면 효율적으로 사용가능
    
- 커스텀 이벤트
    
    서로 등록해 놓은 이벤트를 실행해줄 수 있음
    
    다양한 파일간의 연쇄작용도 가능
    

## 8. 에러 처리하기

- 점원, 주방장이 쓰러지면 모든게 먹통 → 에러처리 중요
- 예외 : 처리하지 못한 에러
    - 예외처리 안하면 스레드 멈춤
    
    ![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%209.png)
    

→ 에러가 아닌것처럼 처리해줌 catch 가 에러를 받아줌

→ 에러가 발생할만한 곳에 try - catch 로 감쌈

- 프로미스의 에러는 따로 처리하지 않아도 됨

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%2010.png)

- 콜백 함수의 동작이 보장되지 않음
- 복구 작업용으로 쓰는 것 부적합
- 에러 내용 기록 용으로만

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fbb8ef2dbd75498ba204552e67d214ef/Untitled%2011.png)