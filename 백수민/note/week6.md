## < 섹션 3. http 모듈로 서버 만들기 >

### 1. 쿠키 이해하기 

**1-1.쿠키**
- 요청-응답 사이클 반복
- 요청에는 한 가지 단점이 존재:
    - 요청을 보냈을 때 서버는 누가 요청을 보냈는지 모름 (IP 주소와 브라우저 정보 정도만 앎)
    - PC방의 경우 모두 같은 IP 사용 => IP를 알아도 정확히 누가 요청을 보냈는지 알 수 없음
    - 로그인을 구현하면 됨
    - 쿠키와 세션이 필요
- 쿠키: 키 = 값의 쌍
    - 요청을 보낼 때 정보를 담아준다
    - name = zerocho
    - 매 요청마다 서버에 동봉해서 보냄 (쿠키)
    - 브라우저가 알아서 쿠키를 서버로 보내준다 (그러므로 우리는 쿠키에다 사용자가 누군지 적기만 하면 된다)
    - 서버는 쿠키를 읽어 누구인지 파악

1. 처음에 요청을 보낼 때 서버가 쿠키와 함께 응답한다. 
2. 이후 요청을 보낼 때 서버에게 받은 쿠키를 함께 보낸다. 
3. 서버는 쿠키를 읽어 요청이 누구로부터 왔는지 파악할 수 있다. 

- writeHead: 요청 헤더에 입력하는 메서드
- Set-Cookie: 브라우저에세 쿠키를 설정하라고 명령
- req.headers.cookie: 쿠키가 문자열로 담겨있음
- req.url: 요청 주소
  
**1-2.헤더와 본문**
- http 요청과 응답은 헤더와 본문을 가짐
    - 헤더는 요청 또는 응답에 대한 정보를 가짐 (데이터들의 데이터)
    - 본문(body)은 주고받는 실제 데이터 
    - 쿠키는 부가적인 정보이므로 헤더에 저장

- **HttpOnly:** 자바스크립트로 쿠키에 접근하지 못하게 한다

**1-3.http 상태 코드**
- writeHead 메서드에 첫 번째 인수로 넣은 값 (요청이 성공했는지 실패했는지 알려줌)
- 2XX: 
    - 성공을 알리는 상태 코드
    - eg) 200(성공), 201(작성됨)
- 3XX:
    - 리다이렉션(다른 페이지로 이동)을 알리는 상태 코드
    - eg) 301(영구 이동), 302(임시 이동)
- 4XX:
    - 요청 오류
    - eg) 401(권한 없음), 403(금지됨), 404(찾을 수 없음)
- 5XX:
    - 서버 오류 (요청은 제대로 왔지만 서버에 오류가 생겼을 때)
    - 이 오류가 뜨지 않게 주의해서 프로그래밍해야 함
    - 이 오류를 클라이언트로 res.writeHead로 직접 보내는 경우는 없고, 예기치 못한 에러 발생 시 서버가 알아서 5XX대 코드를 보냄
    - eg) 500(내부 서버 오류), 502(불량 게이트웨이), 503(서비스를 사용할 수 없음)

---

### 2. 세션 사용하기

쿠키의 정보는 노출되고 수정되는 위험이 있음
- 중요한 정보는 서버에서 관리하고, 클라이언트에는 세션 키만 제공
    - 중요한 정보는 브라우저로 보내지 않고 서버에 남겨둔다. 중요한 정보에 접속할 수 있는 key만 브라우저에 전달하고 브라우저에서는 중요한 정보를 알 수 없게 만든다.
- 서버에 세션 객체(session) 생성 후, uniqueInt(키)를 만들어 속성명으로 사용
- 속성 값에 정보 저장하고 uniqueInt를 클라이언트에 보냄

--- 
### 3. https & http2

**https:**
- https가 적용되면 자물쇠가 채워진다 (chrome)
- https를 적용하면 클라이언트가 서버로 보내는 요청이 암호화 돼서 전달이 된다 (해커가 중간에 탈취해도 풀 수 없음)
- 인증기관에서 인증서를 받아오는 절차가 필요하다 (인증되면 cert, key, ca 파일들을 제공해줌)
- createServer로 서버를 시작할 때 제공 받은 정보를 readFileSync로 읽어서 넣어줘야 한다.
- 공식 무료 인증기관: Let's Encrypt
- 실무에서는 https를 사용해야 한다

**http2:**
- 요청 및 응답 방식이 기존 http/1.1보다 개선이 됨 (동시에 여러 요청 보낼 수 있음)
- 웹의 속도도 개선됨
- 실무에서 적용할 수 있다면 적용하는게 좋음 (속도 + 보안 챙길 수 있음)
- 혼자 개발할 때: http, 실무: http2

--- 
### 4. cluster

- 실무에서는 http2와 함께 cluster도 적용하는 것이 좋다
- 기본적으로 싱글 스레드인 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈
    -  포트를 공유하는 노드 프로세스를 여러 개 둘 수 있음
    - 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산됨
    - 서버에 무리가 덜 감
    - 코어가 8개인 서버가 있을 때: 보통은 코어 하나만 활용
    - cluster로 코어 하나당 노드 프로세스 하나를 배정 가능
    - 성능이 8배가 되는 것은 아니지만 개선됨
    - 단점: 컴퓨터 자원(메모리, 세션 등) 공유 못 함 (프로세스를 여러 개 띄우는 것이기 때문)
    - Redis 등 별도 서버로 해결
- worker_threads: 스레드를 여러 개 만듦, cluster: 프로세스를 여러 개 만듦
- cluster.fork(); => (서버가 에러로 인해 종료돼도 다시 살려준다)

프로그램은 각각 하나씩의 포트를 차지하고 cluster를 하면 여러 개의 서버를 하나의 포트에 같이 묶어 놓을 수 있다.


