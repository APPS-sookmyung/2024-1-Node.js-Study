호출스택
자바스크립트의 동기적(순서대로) 실행
함수선언해서 저장되고 first가 실행되면서 쌓이고 실행된다. 
스택은 먼저 들어간 것이 나중에 나오게 된다. anonymous가 가장 먼저 생긴다. 그리고 코드가 끝나면 사라진다. 

비동기적 실행
setTimeout(run, 3000) -> 3초 뒤에 실행되는 것으로 호출스택으로는 실행 순서를 나타낼 수 없어 코드를 이해하는 데 어려움이 있음
그래서 이를 이해하기 위해 호출스택 외에도 백그라운드, 테스크큐, 콘솔창, 메모리가 도입된다.
setTimeout의 3초 대기는 백그라운드에 들어가서 호출스택과 동시에 실행된다. 
그렇다면, 다 백그라운드로 보내면 효율적이지 않은가?-> 갈 수 있는 유형이 제한되어있다. 또, 백그라운드는 자바스크립트 부분이 아니다.
setTimeout은 0초라도 무조건 백그라운드에 가야한다. (하지만 많이 쓰이는 경우는 아니다.)
백그라운드 안의 코드들은 먼저 시작되는대로 실행된다. 

promise: 동기인 코드이다. 하지만 then을 만나는 순간 비동기가 돼서 백그라운드로 간다. promise의 then은 다른것과 비교했을 때 먼저 실행되기 때문에 새치기를 한다. 

//호출스택 넣어보면서 훈련하면 자바스크립트 마스터가 될 수 있다. //

var: 
요즘에는 별로 쓰지 않는다. 블록 스코프를 무시하기 때문에 블록 바깥에서도 선언한 것을 사용할 수 있다. 하지만 funtion{}는 존중한다는 점이 중요하다. 
const에서는 선언할 때 넣을 값을 나중에 바꾸지 못한다. (=을 한번만 사용할 수 있다. )
let는 값을 바꿀 수 있다. 

const:
코드의 간결화를 가능하게 바뀌었다. 
const는 ${}로 변수를 받아들일 수 있다. (탬플릿 문자열 사용 가능)
function a();
a();
a'';

화살표 함수
위의 것들과 다르게 function을 완전히 대체할 수 없다. 
하지만 return과 {}가 연속되는 경우 생략해서 간결햐ㅏ게 나타낼 수 있다는 장점이 있다. 
하지만 객체를 리턴하는 경우 프로그램은 {}가 지칭하는 것이 무엇인지 알 수 없으므로 따로 ()를 입력해야한다.
this, that관계를 부모 this를 받아들이게 되었으나 자신만의 this를 만들 수 없게 되었으므로 function이 꼭 필요해졌다.(그러므로 this를 쓸 상황이 오면 function을 사용하는 게 좋다.)

구조분해 할당 
예시: 
const example = { a:123, b:{c:135, d:146}}
const a = example.a;
const b = example.b.d;
-> 
const {a, b:{d}} = example;
console.log(a); //123
console.log(d); //146
객체는 키가 일치해야 대응이 된다. 

arr = [1, 2, 3, 4, 5]
const x = arr[0]
const y = arr[1]
const z = arr[4]
->
const [x, y, , ,z] = arr;
배열은 자리가 같아야한다. 순서를 지켜야 함

class: 
프로토타입 문법을 깔끔하게 작성
생성자 함수, 생성자 메소드는 대문자로 선언을 해야한다. 
그룹이라는 걸 알아보기 쉽게 만드는 것
코드를 상속받는 걸 쉽게 하기 위해서 class형태로 정리해주기도 한다. 

promise:
내용이 실행되었지만 결과를 아직 반환하지 않은 객체 
프로미스가 계속 가지고 있다가 then으로 실행을 조절한다. 성공 실패에 대해 실행되는 코드를 조절할 수 있음
콜백헬 계속 코드가 안으로 들어가는 것, 그걸 promise로 일정하게 만들 수 있다. 
promise.all, allSettled 등도 있다. 

async/await(에이싱크 어웨잇):
await이 then역할을 한다. await user.finding() 오른쪽에서 왼쪽으로 실행이 된다. promise들을 반복할 때 사용을 함
await을 쓰려면 async function이 필요한데 요즘은 탑모델 await을 사용할 수 있으면서 제외하기도 함
try catch문 

전문적인 객체:
map:
(키:값)
map {} 키와 값이 1대1로 묶여있다.
특이한 점은 키도 객체 {키:값}로 값도 객체로 지칭할 수 있다.  원래 심볼 아니면 스트링만 지칭 가능하다. 하지만 참조값을 같은 참조값을 가져야 같은 값을 내놓는다. 
사진에서 둘이 다르다고 하는데 왜인지 모르겠다. 
weak map은 (가비지컬랙팅??)도 건드리지 않으면서 할 수 있다. 객체에 부가적 정보를 넣고 싶은데 객체를 수정하고 싶을때 객체를 수정하지 않으면서 부가적인 정보를 담을 수 있다. 
lenght이 아니라 size로 크기를 구한다.
set:
set []은 중복을 허용하지 않는 객체
생성자니까 new를 붙여서 const s = new set()
1 != '1'
중복이 없어야 하는 배열이 필요할 때 쓰면 좋다.
arrat.from()으로 다시 배열로 되돌릴 수 있다. 
mdn으로 더 추가적인 것을 배울 수 있다. 
weakset은 별로 사용하지 않는다. 

null병합 연산자 -> 또는 연산자 
count 
null과 undefined 일때만 뒤로 넘어가고 
c. d를 선언한 다음에 
reading 'd'라고 되어 있므면 c가 오류가 난 것이다. 
a?. b?. c?. d?. e 옵셔널 체이닝으로 오류를 막을 수 있다. 
물음표랑 .이 한세트이다. 

프런트엔드 자바스크립트 
axios-> then, catch
formdata로 이미지를 업로드 할 수 있다. formData 
encodeURIComponent는 한글을 감싸서 오류가 나는 것을 방지한다. I는 identify

li data id 로 html에 데이터를 저장할 수 있다. 