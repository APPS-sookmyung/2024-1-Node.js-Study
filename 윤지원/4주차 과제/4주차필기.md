- 3.5.5 crypto
  다양한 방식의 암호화를 도와주는 모듈 . 암호화 <=>복호화 \*비밀번호는 암호가 아니라 해시라고 한다.
  해시란? 평문을 해시로 만들어 되돌리기 어렵다.주로 비밀번호에서 쓰인다. 서버나 데이터베이스에 해시 형태로 저장되어 있어, 해킹의 위험에 강하다.
  비밀번호 암호화 하는 방법 두가지 1. createHash알고리즘 --> 사용할 해시 알고리즘을 넣는다. 2. pbkdf2, bcrypt, scypt 등..노드에서는 pbkdf2, scypt 지원
  대칭형 암호화 : createCipheriv 사용. 암호화할때와 복호화 할 떄 같은 key를 사용. 프론트와 서버와 key를 공유한다. 프론트에 key를 두면 해커들이 낚아챌 가능성 높음.
  비대칭 암호화: RSA
  ==> 암호학 지식이 없다? crypto-js사용하기
  현업에서 비밀번화 관리하기 -aws kms 많이 사용한다.

- 3.5.6 util -> 각종 편의 기능 모아둔 모듈
  잘못 만든 코드를 표시하고 경고창을 만들고 싶다 : 함부로 삭제할 수 없으니 depreceted 사용.
  자바스크립트가 콜백에서 promise 기반으로 많이 넘어가고 있음. 옛날 콜백으로 이루어진 함수들은 못 없앰 :util.promisfy 를 호출 , 프로미스 패턴으로 바꿀 수 있음 . (조건: 콜백이 (error,data)=>{} 형식이어야 함. 안 지켜지면 못 바꿈 )

- worker threads
  노드에서 멀티스레드를 사용하는 건 극히 드문 일임. 대부분의 경우는 싱글스레드 위주이다. isMainThread로 분기처리를 해주어야 한다.
  메인스레드 (if문) 안에서 워커스레드를 생성하고, 메인스레드(부모)에서 워커스레드로 일을 분배해주는 원리이다. 워커스레드가 일을 마치면 다시 부모로 보내줘서 합쳐서 일을 마치는 형식이다.
  const threads=new Set(); 로 여러 개의 워커스레드를 생성할 수 있다. 여러개의 wt 중에서 끝나는 대로 하나씩 삭제를 하여 size==0이 되면 종료한다.
  분배한 워커의 수만큼 코드를 써서 각각 분배를 해줘야 한다. 워커들이 끝낸 일을 합쳐주는 일도 개발자가 적어주어야 한다. 실무에서는 워커가 에러를 일으키는 경우가 있기 때문에 복구 로직도 구성해둬야 한다. 항상 워커 수에 비례하여 시간이 줄어드는 것은 아니다.

- child process-> 노드 자체로 멀티스레드는 비효율적이므로 다른 프로그램을 띄우고 요청한다. 데이터들을 콘솔로 출력하고, 에러도 확인할 수 있도록 한다.
  유니코드를 콘솔로 표시하려면 nul&&dir 입력하면 된다. 다른 언어로 멀티스레딩을 하고 , 노드에서 만든spawn.js로 그 파일을 호출한다.

  - 3.6 파일 시스템 접근하기
    <동기와 비동기>
    노드에서는 파일 시스템에 접근할 수 있다.
    const fs=require('fs') ( 기본 형태 ) const fs=require('fs').promises
    fs 뒤에 promise를 붙여 promise형식으로 바꿀 수 있다.이때 비동기함수이기 때문에 콜백들을 백그라운드로 보내는데, 백그라운드로 넘어가면 동시에 실행된다. 비동기이기 때문에 누가먼저 끝날지는 운영체제만 알 수 있다. (순서보장 X)백그라운드로 넘어가는 순간 task 큐를 거친다.

    - 따라서 왠만하면 비동기 - 논블로킹이 더 효율적이다. 서버에서는 동기로 하면 순차적으로 실행되기 때문에 동기는 매우 시간이 오래 걸리는 편.
      텍스트 파일 입출력 -> f.writeFile, f.readFile 이때 에러 처리는 필수다. if (err) throw err \*노드에서는 비동기면 논블로킹이고 동기면 블록킹이다 . 동기는 서버 초기화할때나 쓴다.
      sync 처럼 작동하되, 깔끔하게 코드를 짤 수 있는 방법 =>async function main() { let data=await fs.readFile()}
      <버퍼와 스트림>
      버퍼: 일정한 크기로 모아두는 데이터. 일정한 크기가 되면 한 번에 처리함.
      (ex) 데이터는 없는 빈 버퍼 설정하기 : console.log(Buffer.alloc(5)) //5바이트짜리 버퍼
      스트림 : 데이터의 흐름 , 일정한 크기chunk 로 나눠서 여러 번에 걸쳐서 처리함. 파일 읽고 쓰기 대부분의 경우 이 방식이 효율적. 서버에 메모리를 적게 차지하면서 효율적으로 데이터를 보낼 수 있다. 동영상처러 대용량(100기가)인 파일은 스트림으로 쓰면 된다. 1메가를 10만번 보내는 식으로 스트림을 활용해서 전송할 수 있다. writestream.write(' ')
      <pipe와 스트림 메모리 효율 확인>
      readStream.pipe(writestream) : readstream 과 writestream 을 파이프로 연결, 파이프를 통해 n바이트씩 흘러들어가도록 한다. streaming를 하면 다양한 (스트림을 지원하는 것들 대상으로)파이프끼리 연결할수도 있고 압축할 수도 있다. readstream.pipe(zlibStream).pipe(writeStream) \*실습 : 큰 파일 만들기
      폴더추가 -fs.readir , 파일 존재여부 확인 -fs.existsStats
      <스레드풀 알아보기>
      crypto 했을 때 그룹이 나눠짐을 확인할 수 있다. 코어 개수에 맞게 실행할 수 있게 하는 명령어 : SET UV_THREADPOOL_SIZE=8
      워커 개수, threadpool 개수도 컴퓨터 사양에 맞게 맞추면 효율적이다.

      <커스텀 이벤트 > 연쇄작용 가능
      나만의 커스텀 이벤트 만들기 - const EventEmitter= require('events') ; const myEvent=new EventEmitter;
      myEvent.emit('event1'); => 이벤트 호출
      myEvent.removeListeners('event5',listener); => 어떤 콜백함수를 지울지 넣어줌
      myEvent.listenerCount ( )

  - 3.8 예외 처리하기
    노드는 에러 나지 않게 관리를 잘 해줘야 한다. (작동을 못하게 되기 때문에)
    자바스크립트에서는 예외와 에러가 큰 차이가 없음 . 가장 쉬운 방법은 trycatch 로 에러나는 부분을 캐치함.
    promise 에다가 캐치 안 붙이면 발생하는 에러 -> unhandledPromiseRejectionWarning
    promise -> 왠만하면 캐치 붙이기

    에러를 기록해주는 용도 : process.on('uncaughtExcetion', (err))=> console.log('에러',err) 에러 내용 기록 용으로만 쓰는게 좋음. 에러가 났을 떄
    빠르게 코드 자체를 고치는게 중요함.

    프로세스 종료하기 : netstat -ano |findstr 포트 $taskill/pid 프로세스아이디 /f (강제종료)
