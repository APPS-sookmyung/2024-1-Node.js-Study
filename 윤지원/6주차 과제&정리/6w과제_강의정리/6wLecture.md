<1.쿠키의 필요성>
요청의 문제점: 누가 요청을 보냈는지 모름. 서버는 IP주소와 브라우저 정보 정도만 앎.따라서 로그인을 구현하여 요청이 누구인지 알아야 함.
로그인을 하려면 쿠키와 세션에 대해서 알아야 함. 쿠키는 로그인에만 쓰이진 않고, 요청을 넣을 떄 정보를 보여줌.
\*\*초보자 입장에서는 로그인할 때 직접 데이터 전송보다는 쿠키 전송이 보안적인 측면에서 낫다=> 브라우저에서 안전장치를 제공해주기 때문.

쿠키: 키=값의 쌍.
이때 브라우저는 쿠키를 저장하고 있다가 서버에 동봉하여 보내줌=>서버가 읽어서 누군지 식별함.
쿠키 넣는 것을 구현하기=> writeHead 메서드의 헤더에 set-cookie 넣을 수 있음. 이때 처음 넣어서 보내주면 다음 요청 부터는 서버쪽에서 분별 가능한 것임.
세션쿠키: 브라우저를 닫으면 쿠키가 사라짐

<헤더와 본문>
본문: 요청의 데이터로 , 주고받는 실제 데이터이다
헤더: 데이터들의 데이터, 즉 요청 또는 응답에 대한 정보를 가짐
요청과 응답은 헤더와 데이터로 구성되어 있다. 이때 쿠키는 부가적인 정보이므로 헤더에 저장한다.

<쿠키로 나를 식별하기>

- 쿠키에 내 정보를 입력
  parseCookies: 쿠키 문자열을 객체로 변환. 주소가 /login 인 경우 &/인 경우로 나뉨.
  /login 인 경우: 쿼리스트링으로 온 이름을 쿠키로 저장.
  그 위 경우: 쿠키의 유무 판단. 있다면 -> 환영인사 없다면 -> 로그인 페이지로 다이렉트.이렇게 분기 처리해주면 restserver에도 코드가 복잡해질 수 있다는 문제점이 있음.
- GET 요청에다가 로그인하고, 데이터는 GET 요청인 경우에 querystring으로 뒤에 들어감.

서버로 전달되는 형태: 겟 요청-로그인-퀴리 스트링-name(입력)
'''if (req.url.startsWith("/login")) {
const url = new URL(req.url, "http://localhost:8084");
const name = url.searchParams.get("name");''' 이 코드에서 응답을 받음. 쿼리스트링에서 name을 추출한다.
응답을 받는 writeHead의 헤더에 301, 302가 오면 리다이렉트이다.

- 쿠키 유효 시간을 현재시간 + 5분으로 설정
  expires.setMinutes(expires.getMinutes() + 5);
  res.writeHead(302, {
- 302: redirection. 응답을 받으면서 /주소로 리다이렉트 되는 것
  Location: "/",
  "Set-Cookie": `name=${encodeURIComponent(
  name
)}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`,
  }); // 직접 쿠키 만료시간을 적어주는 부분. 이부분 안 적어주면 세션 쿠키 되는 것
- HTTpOnly: 자바스크립트로 접근하면 해킹의 위험이 있다. 로그인을 위해서 사용하는 쿠키는 http only가 거의 필수이다.

<세션 방법>

> > 쿠키의 정보는 노출되고 수정되는 위험이 있음. 따라서 중요한 정보를 브라우저로 보내지 않고, 서버에서 관리. (클라이언트)브라우저에는 정보에 접속할 수 있는 세션 키만 제공.
> > But 실제 서버에서는 세션을 직접 구현하지 말자 - 6장에서 나오는 express-session 사용하기

- 서버에 세션 객체 생성 후,uniqueInt(키)를 만들어 '고유한' 속성명으로 사용.
- 속성 값에 정보 저장하고 (name이나 eㄴxpires가 아닌) uniqueInt를 클라이언트에 보냄
  ==application 에서 해커들이 봐도 모를만한 데이터로 표시됨

<https와 http2>
개발할때는 http, 배포할때는 http2로.

- https: 웹 서버에 SSL 암호화를 추가하는 모듈. 오고 가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없음. 실무에서는 https적용이 필수
  - 코드상에서는 콜백만 있는것이 아니라 인수가 추가됨 (cert,key,ca). 이 인수들로 인증서 경로, 비밀키 경로를 파일로 받아 저장함. 이 부분에서 딱 한번만 등장하는 readFileSync -> 서버를 초기화할때는 sync 쓸 수 있음
  - https에서는 포트가 443임
- http2: SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용하는 모듈. 요청 및 응답 방식, & 웹 속도가 기존 http보다 개선됨. 즉, 동시성을 늘려 요청을 여러개 동시에 보내서 더 빠르게 받아옴 . 작은 이미지같은 경우는 http2가 훨씬 빠름. 실무에서 적용하면 좋음 !

<cluster>
>>기본적으로 싱글 스레드인 노드가 cpu 코어를 모두 사용할수 있게 해주는 모듈. 포틀르 공유하는 노드 프로세스를 여러개 둘 수 있음. 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산됨. 서버에 무리가 덜 가기 떄문에 실무에서 http2와 같이 사용하기 좋음. 
- 서버가 기본적으로 싱글스레드여서 코어를 하나밖에 안 차지함. 따라서 서버를 코어 개수만큼 실행해주면 코어 하나당 서버 하나를 할당할 수 있음. 이를 가능케 하는 것이 cluster. 
- 성능이 8배가 되는 것은 아니지만 , 어느정도 개선 됨. 하나의 포트에서 내 cpu 개수만큼의 서버를 띄울 수 있음. ==** 하나의 포트만 쓸 수 있다!!!.
  이때 서버는 프로세스는 n+1개( 마스터 프로세스 1개+ 워커 프로세스 n개)
-  단점: 컴퓨터 자원(메모리, 세션 등) 공유 못 함 . redis 등 별도 서버로 해결-15장
- 워커 스레드: 스레드 여러 개 vs 클러스터 :프로세스 여러 개
- 실무 적용 방법: https, http2 와 동시에 클러스터 코드 추가 - >서버가 실수로 꺼지더라도 다시 살림
 restserver-session-server 로 나만의 웹사이트만들어보기 . 다만 http2는 도메인, 인증서가 없기 때문에 적용 못함
